# 技术框架设计文档

> 本文档记录各步骤的设计方案与决策，采用追加式记录。

---

## 整体框架设计

### 项目架构概述

| 层级 | 模块 | 说明 |
|------|------|------|
| 入口 | main.ts + AppModule | NestJS 应用入口，全局 ExceptionFilter、CORS、ConfigModule |
| 基础设施 | DatabaseModule | Drizzle ORM + Neon，全局注入 |
| 认证 | AuthModule | BetterAuth 桥接，/api/auth/* |
| 业务 | PostsModule、UsersModule | 内容发布、点赞、用户信息 |
| 存储 | StorageModule（已实现） | R2 Presigned URL，前端直传 |

**关键数据流**：请求 → CORS → ExceptionFilter → AuthGuard（需登录接口）→ Controller → Service → Drizzle/Neon

**技术决策**：全栈 TypeScript、Serverless 优先；容器化隔离、配置隔离、存储抽象隔离。

### 开发步骤规划

| 步骤 | 目标 | 交付物 |
|------|------|--------|
| 第一步 | 工程骨架 | NestJS 骨架、健康检查、Dockerfile、安全基线 |
| 第二步 | 数据库 | DatabaseModule、Drizzle、Schema 骨架 |
| 第三步 | 用户认证 | BetterAuth、注册/登录/会话、4 张认证表 |
| 第四步 | 核心业务 | 发帖、点赞、用户信息、post/post_like 表 |
| 第五步 | 对象存储（已实现） | StorageService、R2 Presigned URL、media_urls 扩展 |
| 后续 | 评论、关注等 | 按业务优先级推进 |

### 步骤间依赖关系

```
第一步（工程初始化） ─┬→ 第二步（数据库） ─→ 第三步（认证） ─→ 第四步（核心业务） ─→ 第五步（存储）
                     └→ 第二步 依赖 第一步 的 package.json、tsconfig
第三步 依赖 第二步 的 DatabaseModule、Schema
第四步 依赖 第三步 的 AuthModule（AuthGuard）
第五步 依赖 第四步 的 post 表（扩展 media_urls）
```

- 第一步为起点，无前置依赖
- 第二步、第三步、第四步、第五步为**顺序依赖**，不可并行
- API 错误响应规范、整体 ExceptionFilter 在第四步实现时生效

### 跨步技术约定

| 约定项 | 说明 |
|--------|------|
| **统一错误响应** | 业务接口统一返回 `{ code, message }`，详见下方「API 错误响应规范」 |
| **鉴权机制** | Cookie + AuthGuard，需登录接口统一校验，未登录返回 `UNAUTHORIZED` |
| **CORS** | 由环境变量 `CORS_ORIGIN` 控制允许的前端地址，`credentials: true` 支持跨域携带 Cookie |

---

## API 错误响应规范

> 以下规范自第四步起生效，业务接口（`/api/posts`、`/api/users` 等）统一遵循。认证接口（`/api/auth/*`）由 BetterAuth 管理，其 `{ code, message }` 格式与本规范一致，前端可统一解析。

### 【统一错误格式】

所有业务接口的错误响应统一为：

```json
{
  "code": "ERROR_CODE",
  "message": "人类可读的错误描述"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| code | string | 机器可读错误码，大写下划线（如 `UNAUTHORIZED`） |
| message | string | 人类可读描述，供前端展示或日志 |

### 【实现方式】

- 全局 ExceptionFilter：拦截 NestJS 抛出的 `HttpException` 及子类，输出上述格式
- 业务代码通过 `throw new UnauthorizedException('未登录或会话已过期')` 等抛出，由 Filter 转换为 `{ code: "UNAUTHORIZED", message: "..." }`
- HTTP 状态码与 `code` 对应关系见下表

### 【HTTP 状态码与 code 映射】

| HTTP 状态码 | code | 典型场景 |
|------------|------|------|
| 400 | `BAD_REQUEST` | 参数校验失败、业务规则违反 |
| 401 | `UNAUTHORIZED` | 未登录、会话过期 |
| 403 | `FORBIDDEN` | 无权限访问资源 |
| 404 | `NOT_FOUND` | 资源不存在 |
| 409 | `CONFLICT` | 唯一约束冲突（如重复点赞时的幂等处理） |
| 422 | `UNPROCESSABLE_ENTITY` | 业务逻辑不可执行 |
| 500 | `INTERNAL_SERVER_ERROR` | 未预期服务器错误 |

### 【各接口错误清单】

各业务接口的详细错误码、触发条件在《API接口文档》中按接口补充「失败场景」表格。第四步涉及接口示例：

| 接口 | 失败场景 |
|------|------|
| POST /api/posts | 401 未登录；400 缺少 content / content 为空 |
| GET /api/posts | 401 未登录 |
| POST /api/posts/:id/like | 401 未登录；404 post 不存在 |
| GET /api/users/me | 401 未登录 |
| GET /api/users/:id | 401 未登录；404 用户不存在 |

---

## 第一步：工程初始化与基础配置

### 【本步目标】
- 交付可运行的 NestJS 工程骨架（含健康检查接口 `GET /health`）
- 一次性声明全部技术栈依赖
- 完成基础配置文件与安全基线

### 【技术方案】

#### 目录结构
```
AI-Coding-Museum/
├── src/
│   ├── main.ts                    # NestJS 入口（端口通过 process.env.PORT 读取，默认 3000）
│   ├── app.module.ts              # 根模块（集成 ConfigModule 全局环境变量管理）
│   └── health/
│       ├── health.controller.ts   # GET /health → { status, timestamp }
│       └── health.module.ts       # 健康检查模块
├── package.json                   # 全量依赖声明
├── tsconfig.json                  # TypeScript 配置（target: ES2022, decorators 支持）
├── tsconfig.build.json            # 构建配置（排除测试文件）
├── nest-cli.json                  # NestJS CLI 配置（编译输出 dist/）
├── .env.example                   # 环境变量模板（仅占位符）
├── .gitignore                     # 排除 .env、*.key、secrets/、dist/
├── SECURITY.md                    # 安全说明（环境变量管理规范）
└── Dockerfile                     # 多阶段构建（Node 22 Alpine）
```

#### 依赖清单
| 类型 | 包名 | 用途 |
|------|------|------|
| dependencies | `@nestjs/core`, `@nestjs/common`, `@nestjs/platform-express` | NestJS 核心（Express 为底层 HTTP 引擎） |
| dependencies | `@nestjs/config` | 环境变量管理 |
| dependencies | `reflect-metadata`, `rxjs` | NestJS 运行时依赖 |
| dependencies | `drizzle-orm` | ORM 核心 |
| dependencies | `better-auth` | 鉴权系统 |
| dependencies | `@neondatabase/serverless` | Neon PostgreSQL 驱动 |
| dependencies | `@upstash/redis` | Upstash Redis 客户端 |
| dependencies | `@aws-sdk/client-s3` | Cloudflare R2 对象存储（S3 兼容） |
| devDependencies | `typescript`, `ts-node`, `tsconfig-paths` | TypeScript 工具链 |
| devDependencies | `@nestjs/cli` | NestJS CLI |
| devDependencies | `@types/node`, `@types/express` | 类型定义 |
| devDependencies | `drizzle-kit` | Schema 迁移工具 |

#### 关键设计决策
1. **Express 作为 NestJS 底层 HTTP 引擎**：NestJS 必须选择 Express 或 Fastify 之一，Express 为默认选项，生态最成熟。业务代码不直接调用 Express API，无需在技术栈选型文档中单独列出。
2. **ConfigModule 全局注入**：`isGlobal: true` 确保所有模块可直接注入 `ConfigService`，统一管理环境变量。
3. **Dockerfile Day 1 就绪**：遵循技术栈方案"容器化隔离"要求，多阶段构建确保生产镜像最小化。

#### 外部服务依赖
本步无（纯骨架验证）

### 【需您准备】
- 无（端口通过 `process.env.PORT` 读取，代码默认 3000，可本地覆盖）

### 【安全验证点】
- ✅ 代码中无硬编码密钥（端口通过 `process.env.PORT` 读取）
- ✅ `.gitignore` 已排除 `.env`、`*.key`、`secrets/`、`dist/`
- ✅ `.env.example` 仅含变量名 + 尖括号占位符，无真实值
- ✅ `SECURITY.md` 已提供
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 安装依赖 | `npm install` | 无报错 | ✅ 486 packages 安装成功 |
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `npm run start` | 控制台输出启动信息 | ✅ 正常启动 |
| 健康检查 | `curl http://localhost:3000/health` | HTTP 200；`{ status, timestamp }` | ✅ `{"status":"ok","timestamp":"2026-02-16T10:59:24.851Z"}` |
| Docker 构建 | `docker build -t ai-coding-museum .` | 镜像构建成功 | ✅ 14 步全部完成（Node 22 Alpine 多阶段构建） |
| Docker 运行 | `docker run -p 3000:3000 ai-coding-museum` + `curl /health` | HTTP 200；容器内服务正常响应 | ✅ `{"status":"ok","timestamp":"2026-02-18T12:29:39.366Z"}` |

---

## 第二步：数据库接入与 Drizzle ORM 配置

### 【本步目标】
- 完成 Neon PostgreSQL 数据库连接（通过 Drizzle ORM）
- 建立数据库模块（`DatabaseModule`），全局可注入
- 配置 Drizzle Kit 迁移工具
- 健康检查接口增加数据库连接状态

### 【技术方案】

#### 新增目录结构
```
src/
├── database/
│   ├── database.module.ts         # 全局数据库模块（@Global）
│   ├── database.provider.ts       # Drizzle 实例工厂（neon + drizzle-orm/neon-http）
│   └── schema/
│       └── index.ts               # Schema 统一导出（骨架）
drizzle.config.ts                  # Drizzle Kit 迁移配置（根目录）
```

#### 关键设计决策
1. **Neon HTTP 驱动**：使用 `drizzle-orm/neon-http` + `@neondatabase/serverless` 的 `neon()` 函数，走 HTTP 协议连接 Neon，适合 Serverless 场景（无需维护连接池）。
2. **Provider 注入模式**：通过 `Symbol('DRIZZLE')` 作为注入令牌，业务模块使用 `@Inject(DRIZZLE)` 获取 Drizzle 实例。
3. **全局模块**：`DatabaseModule` 标记 `@Global()`，所有模块无需重复导入即可注入数据库实例。
4. **Schema 骨架**：`schema/index.ts` 导出空对象，后续步骤定义表结构时追加导出。

#### 外部服务依赖
- Neon PostgreSQL（通过 `DATABASE_URL` 环境变量连接）

### 【需您准备】
- [x] 变量名：`DATABASE_URL` | 用途：Neon PostgreSQL 连接串 | 获取方式：Neon 控制台

### 【安全验证点】
- ✅ 数据库连接串仅通过 `process.env.DATABASE_URL` 读取
- ✅ `drizzle.config.ts` 同样通过 `process.env.DATABASE_URL!` 读取
- ✅ `.env.example` 中 `DATABASE_URL=<YOUR_NEON_DATABASE_URL>`（仅占位符）
- ✅ `.env` 包含真实值但被 `.gitignore` 排除
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `node dist/main.js` | 无数据库连接错误 | ✅ 正常启动 |
| 健康检查（含DB） | `curl http://localhost:3000/health` | HTTP 200；`{ status, timestamp, database: "connected" }` | ✅ `{"status":"ok","timestamp":"2026-02-18T13:11:32.429Z","database":"connected"}` |

---

## 第三步：用户认证系统（BetterAuth + Drizzle）

### 【本步目标】
- 集成 BetterAuth 认证框架，实现用户注册/登录/会话管理
- 通过 Drizzle ORM 定义认证相关数据库表（user、session、account、verification）
- 提供认证 API 端点（`/api/auth/*`）
- 执行首次数据库迁移（drizzle-kit generate + migrate）

### 【技术方案】

#### 新增目录结构
```
src/
├── auth/
│   ├── auth.module.ts             # 认证模块
│   ├── auth.service.ts            # BetterAuth 实例封装（drizzleAdapter + emailAndPassword）
│   └── auth.controller.ts         # 转发所有 /api/auth/* 请求给 BetterAuth 的 toNodeHandler
├── database/
│   └── schema/
│       └── index.ts               # 新增 4 张 BetterAuth 核心表定义
drizzle/
└── 0000_workable_stone_men.sql    # 首次迁移 SQL（4 表 + 外键）
```

#### 关键设计决策
1. **BetterAuth + Drizzle 适配器**：使用 `drizzleAdapter(db, { provider: 'pg', schema })` 将认证数据存储到 Neon，复用已有的 Drizzle 实例和 Schema 定义。
2. **NestJS 桥接**：通过 `toNodeHandler(auth)` 将 BetterAuth 的 Web 标准请求处理器转为 Node.js Handler，在 NestJS Controller 中使用 `@All()` + `@All('*path')` 捕获所有 `/api/auth/*` 路由。
3. **Schema 定义**：按 BetterAuth 源码中 `getAuthTables()` 的字段定义，在 Drizzle Schema 中手动定义 4 张表，使用 snake_case 数据库列名 + camelCase TypeScript 属性名。
4. **会话管理**：BetterAuth 默认使用 HttpOnly Cookie（`better-auth.session_token`），有效期 7 天，自动续期。

> ⚠️ **Cookie 值格式说明**：
> - `Set-Cookie` 响应头中的值为 `token.HMAC签名`（如 `w4aYWnc1...NJV.5q3qW3A...GUo%3D`），其中 `.` 前是 session token 标识，`.` 后是基于 `AUTH_SECRET` 的 HMAC 签名。
> - JSON 响应体中的 `token` 字段仅包含 `.` 前的 session token 部分，**不含签名**。
> - `get-session` 接口校验时需要完整的 `token.签名` 值（即 `Set-Cookie` 中的原始值），仅传 JSON body 中的 `token` 会因签名缺失导致返回 `null`。
> - 使用 curl 测试时推荐 `-c tmp/cookies.txt`（保存）+ `-b tmp/cookies.txt`（发送）方式，避免手动复制 token 出错。

#### 数据库表结构设计

BetterAuth 要求 4 张核心表，字段定义严格遵循其内部 `getAuthTables()` 规范：

**① user 表 — 用户主表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 用户唯一标识（BetterAuth 自动生成） |
| name | text | NOT NULL | 用户显示名称 |
| email | text | NOT NULL, UNIQUE | 邮箱（登录凭证，全局唯一） |
| email_verified | boolean | NOT NULL, DEFAULT false | 邮箱是否已验证 |
| image | text | 可空 | 用户头像 URL |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

**② session 表 — 会话表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 会话唯一标识 |
| expires_at | timestamp | NOT NULL | 会话过期时间（默认 7 天后） |
| token | text | NOT NULL, UNIQUE | 会话令牌（存入 Cookie 用于身份校验） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |
| ip_address | text | 可空 | 登录时的客户端 IP |
| user_agent | text | 可空 | 登录时的浏览器/客户端标识 |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |

**③ account 表 — 账户表（支持多种登录方式）**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 账户唯一标识 |
| account_id | text | NOT NULL | 提供商侧的账户 ID（邮箱登录时为邮箱） |
| provider_id | text | NOT NULL | 登录提供商标识（如 `credential`、`github`） |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |
| access_token | text | 可空 | OAuth access token（邮箱登录无此字段） |
| refresh_token | text | 可空 | OAuth refresh token |
| id_token | text | 可空 | OAuth id token |
| access_token_expires_at | timestamp | 可空 | access token 过期时间 |
| refresh_token_expires_at | timestamp | 可空 | refresh token 过期时间 |
| scope | text | 可空 | OAuth 授权范围 |
| password | text | 可空 | 邮箱密码登录时的哈希密码（BetterAuth 自动加盐哈希） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：一个 user 可关联多个 account（如同时支持邮箱密码 + GitHub OAuth），通过 `provider_id` 区分。当前仅启用 `emailAndPassword`，预留 OAuth 扩展能力。

**④ verification 表 — 验证表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 验证记录唯一标识 |
| identifier | text | NOT NULL | 验证目标标识（如邮箱地址） |
| value | text | NOT NULL | 验证码/令牌值 |
| expires_at | timestamp | NOT NULL | 验证码过期时间 |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：用于邮箱验证、密码重置等场景的临时令牌存储。当前 MVP 阶段未启用邮箱验证流程，表结构已就绪待后续使用。

**表间关系**：
```
user (1) ←─── (N) session    （一个用户可有多个活跃会话）
user (1) ←─── (N) account    （一个用户可有多种登录方式）
verification                  （独立表，无外键关联）
```

#### 外部服务依赖
- Neon PostgreSQL（已接入）
- BetterAuth 需要 `AUTH_SECRET` 签名密钥

### 【需您准备】
- [x] 变量名：`AUTH_SECRET` | 用途：BetterAuth 签名密钥 | 获取方式：`openssl rand -hex 32` 生成
- [x] 变量名：`BETTER_AUTH_URL` | 用途：应用公开访问地址 | 获取方式：本地开发填 `http://localhost:3000`

### 【安全验证点】
- ✅ `AUTH_SECRET` 仅通过 `process.env.AUTH_SECRET` 读取，未配置时抛出明确错误
- ✅ `.env.example` 新增 `AUTH_SECRET` 和 `BETTER_AUTH_URL` 占位符
- ✅ 密码由 BetterAuth 内部自动加盐哈希，不手写加密逻辑
- ✅ 会话 Cookie 设置 HttpOnly + SameSite=Lax
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 数据库迁移 | `npx drizzle-kit generate` + `npx drizzle-kit migrate` | 迁移执行成功，4 张表已创建 | ✅ 迁移执行成功，user, session, account, verification 表已创建 |
| 用户注册 | `POST /api/auth/sign-up/email` | HTTP 200；返回用户信息 + token | ✅ 返回 `{ token, user: { id, name, email, ... } }` |
| 用户登录 | `POST /api/auth/sign-in/email` | HTTP 200；返回用户信息 + token + Set-Cookie | ✅ 返回用户信息，设置 `better-auth.session_token` Cookie |
| 获取会话 | `GET /api/auth/get-session`（携带 Cookie） | HTTP 200；返回 session + user | ✅ 返回完整会话和用户信息 |
| 健康检查 | `GET /health` | HTTP 200；仍正常返回 | ✅ `{"status":"ok","database":"connected"}` |

---

## 第四步：核心业务骨架（内容发布 + 点赞 + 用户信息）

### 【本步目标】
- 实现全局 ExceptionFilter，输出统一错误格式（见「API 错误响应规范」）
- 实现内容发布（纯文本）、内容浏览（时间流分页）
- 实现点赞互动（唯一索引防重复）
- 实现用户信息接口（当前用户 / 他人主页）
- 所有业务接口需登录态（BetterAuth Cookie 鉴权）
- **本步不涉及 R2**，media 字段预留为扩展

### 【技术方案】

#### 新增目录结构
```
src/
├── common/
│   └── http-exception.filter.ts   # 全局 ExceptionFilter，统一错误格式
├── auth/
│   └── auth.guard.ts              # 会话鉴权 Guard，供需登录接口复用
├── posts/
│   ├── posts.module.ts
│   ├── posts.controller.ts        # POST/GET /api/posts
│   ├── posts.service.ts
│   └── dto/
├── users/
│   ├── users.module.ts
│   ├── users.controller.ts        # GET /api/users/me, /api/users/:id
│   └── users.service.ts
├── database/
│   └── schema/
│       └── index.ts               # 新增 post、post_like 表
```

#### 数据库表设计

**① post 表 — 内容**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK, DEFAULT gen_random_uuid() | 主键 |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 作者 |
| content | text | NOT NULL | 正文（纯文本，MVP 无富文本） |
| media_urls | jsonb | 可空 | 预留，格式 `["url1","url2"]`，本步不用 |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| updated_at | timestamp | NOT NULL, DEFAULT now() | |

**② post_like 表 — 点赞**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK | |
| user_id | text | NOT NULL, FK → user.id | |
| post_id | uuid | NOT NULL, FK → post.id | |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| UNIQUE(user_id, post_id) | | 联合唯一 | 防重复点赞 |

#### API 设计
| 方法 | 路径 | 鉴权 | 说明 |
|------|------|------|------|
| POST | /api/posts | 需登录 | 发帖（body: `{ content }`） |
| GET | /api/posts | 需登录 | 时间流分页（query: `cursor`, `limit`） |
| POST | /api/posts/:id/like | 需登录 | 点赞/取消点赞（toggle） |
| GET | /api/users/me | 需登录 | 当前用户信息（含 id,name,email,image） |
| GET | /api/users/:id | 需登录 | 他人信息（脱敏：无 email，仅 id,name,image） |

#### 外部服务依赖
- 无新增（仅 Neon + BetterAuth，已接入）

### 【需您准备】
- 无新增环境变量

### 【安全验证点】
- ✅ 所有业务接口需 Cookie 鉴权
- ✅ 发帖/点赞仅限登录用户
- ✅ 他人信息接口不返回 email

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 未登录发帖 | `POST /api/posts` 无 Cookie | HTTP 401；`{ code: "UNAUTHORIZED", message: "..." }` | ✅ `{"code":"UNAUTHORIZED","message":"未登录或会话已过期"}` |
| 发帖 | 登录后 `POST /api/posts` body `{"content":"hello"}` | HTTP 201；返回 post | ✅ 返回 post 对象 |
| 浏览时间流 | `GET /api/posts?limit=10` 带 Cookie | HTTP 200；返回 post 列表 | ✅ 返回数组 |
| 点赞 | `POST /api/posts/:id/like` 带 Cookie | HTTP 200；toggle 成功 | ✅ 返回 `{ liked: true/false }` |
| 当前用户 | `GET /api/users/me` 带 Cookie | HTTP 200；返回 user | ✅ 返回完整 user |
| 他人信息 | `GET /api/users/:id` 带 Cookie | HTTP 200；不包含 email | ✅ 返回脱敏 user |

---

## 第五步：对象存储（R2 Presigned URL）

### 【本步目标】
- 创建 StorageModule 和 StorageService
- 实现 R2 Presigned URL 生成（前端直传）
- 提供获取上传预签名 URL 的 API
- 更新发帖接口支持 mediaUrls 字段

### 【技术方案】

#### 新增目录结构
```
src/
├── storage/
│   ├── storage.module.ts        # 存储模块
│   ├── storage.service.ts       # R2 客户端 + Presigned URL 生成
│   └── storage.controller.ts    # GET /api/storage/upload-url
```

#### 关键设计决策

1. **前端直传模式**：后端生成预签名 URL，前端直接 PUT 上传到 R2，减轻后端压力
2. **文件类型限制**：
   - 图片：jpeg/png/gif/webp，最大 5MB
   - 视频：mp4/webm，最大 50MB
3. **路径隔离**：按 userId 隔离存储路径 `uploads/{userId}/{uuid}.{ext}`
4. **预签名有效期**：15 分钟

#### API 设计

**GET /api/storage/upload-url**

Query 参数：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| filename | string | ✅ | 原始文件名 |
| contentType | string | ✅ | 文件 MIME 类型 |

成功返回（HTTP 200）：
```json
{
  "uploadUrl": "https://xxx.r2.cloudflarestorage.com/uploads/userId/uuid.jpg?X-Amz-...",
  "objectKey": "uploads/userId/uuid.jpg",
  "publicUrl": "https://pub-xxx.r2.dev/uploads/userId/uuid.jpg"
}
```

失败场景：
| HTTP | code | 触发条件 |
|------|------|----------|
| 401 | UNAUTHORIZED | 未登录 |
| 400 | BAD_REQUEST | 缺少参数 / 文件类型不支持 |

**POST /api/posts**（更新）

请求体新增字段：
| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| mediaUrls | string[] | 否 | 已上传媒体的公开 URL 数组 |

#### 前端上传流程

```
1. 用户选择文件
2. 前端调用 GET /api/storage/upload-url?filename=test.jpg&contentType=image/jpeg
3. 后端返回 { uploadUrl, objectKey, publicUrl }
4. 前端使用 PUT uploadUrl 直接上传文件到 R2
5. 上传成功后，前端调用 POST /api/posts 传递 publicUrl
```

#### 外部服务依赖
- Cloudflare R2（通过环境变量配置）

### 【需您准备】
- [x] 变量名：`R2_ENDPOINT` | 用途：R2 S3 API 端点 | 获取方式：创建 R2 API Token 时显示的 jurisdiction-specific endpoint
- [x] 变量名：`R2_ACCESS_KEY_ID` | 用途：R2 Access Key | 获取方式：创建 R2 API Token
- [x] 变量名：`R2_SECRET_ACCESS_KEY` | 用途：R2 Secret Key | 获取方式：创建 R2 API Token
- [x] 变量名：`R2_BUCKET_NAME` | 用途：R2 存储桶名称 | 获取方式：创建 R2 Bucket
- [x] 变量名：`R2_PUBLIC_URL` | 用途：R2 公开访问域名 | 获取方式：配置 R2 Custom Domain 或使用默认域名

### 【安全验证点】
- ✅ 文件类型白名单校验（MIME type）
- ✅ 预签名 URL 有效期 15 分钟
- ✅ 路径隔离：按 userId 隔离存储
- ✅ 需登录：AuthGuard 保护

### 【测试方案与结果】

| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 健康检查 | `GET /health` | HTTP 200 | ✅ `{"status":"ok","database":"connected"}` |
| 登录 | `POST /api/auth/sign-in/email` | HTTP 200 | ✅ 返回 token 和 user |
| 获取上传 URL | `GET /api/storage/upload-url?filename=test.jpg&contentType=image/jpeg` | HTTP 200；返回 uploadUrl, objectKey, publicUrl | ✅ 返回完整预签名信息 |
| 上传文件 | `PUT <uploadUrl>` | HTTP 200 | ✅ 上传成功 |
| 发帖带媒体 | `POST /api/posts` body `{"content":"带图片","mediaUrls":["..."]}` | HTTP 201；返回包含 mediaUrls 的 post | ✅ mediaUrls 正确保存 |
| 文件类型校验 | `GET /api/storage/upload-url?filename=test.exe&contentType=application/octet-stream` | HTTP 400；不支持的文件类型 | ✅ `{"code":"BAD_REQUEST","message":"不支持的文件类型"}` |
| 未登录访问 | `GET /api/storage/upload-url` 无 Cookie | HTTP 401 | ✅ `{"code":"UNAUTHORIZED","message":"未登录或会话已过期"}` |
| 浏览时间流 | `GET /api/posts?limit=10` | HTTP 200；返回含 mediaUrls 的列表 | ✅ mediaUrls 正确返回 |

---

## 第六步：评论系统（楼中楼 + 点赞 + 删除）

### 【本步目标】

- 实现评论发布、回复（楼中楼）、点赞、删除功能
- 支持最多 5 层嵌套，顶级评论按点赞数排序
- 交付 comment、comment_like 表及完整 CRUD API

### 【技术方案】

#### 新增目录结构

```
src/
├── comments/
│   ├── comments.module.ts
│   ├── comments.controller.ts
│   ├── comments.service.ts
│   └── dto/
│       ├── create-comment.dto.ts
│       ├── query-comments.dto.ts
│       └── index.ts
```

#### 数据库表设计

**① comment 表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK | 主键 |
| post_id | uuid | NOT NULL, FK → post.id | 所属帖子 |
| user_id | text | NOT NULL, FK → user.id | 评论作者 |
| content | text | NOT NULL | 评论内容（纯文本） |
| parent_id | uuid | 可空, FK → comment.id | 父评论 ID |
| depth | integer | NOT NULL, DEFAULT 0 | 嵌套深度（0-4，共 5 层） |
| like_count | integer | NOT NULL, DEFAULT 0 | 点赞数 |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| updated_at | timestamp | NOT NULL, DEFAULT now() | |
| deleted_at | timestamp | 可空 | 软删除标记 |

**② comment_like 表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK | 主键 |
| user_id | text | NOT NULL, FK → user.id | 点赞用户 |
| comment_id | uuid | NOT NULL, FK → comment.id | 被点赞评论 |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| UNIQUE(user_id, comment_id) | | 联合唯一 | 防重复点赞 |

#### API 设计

| 方法 | 路径 | 鉴权 | 说明 |
|------|------|------|------|
| POST | /api/posts/:postId/comments | 需登录 | 发表评论/回复 |
| GET | /api/posts/:postId/comments | 需登录 | 获取评论列表（树形结构） |
| POST | /api/comments/:id/like | 需登录 | 点赞/取消点赞 |
| DELETE | /api/comments/:id | 需登录 | 删除评论（作者或帖主） |

#### 排序逻辑

- 顶级评论：按点赞数倒序，点赞数相同时按时间倒序
- 嵌套回复：按时间正序（保持对话顺序）

### 【需您准备】

- 无新增环境变量

### 【安全验证点】

- ✅ 评论需登录态
- ✅ 嵌套深度校验（最多 5 层）
- ✅ 删除权限校验（仅作者或帖主可删除）
- ✅ 软删除保留数据（deleted_at 标记）

### 【测试方案与结果】

| 步骤 | 预期 | 结果 |
|------|------|------|
| 编译 | 无错误 | ✅ 编译成功 |
| 数据库迁移 | comment、comment_like 表创建成功 | ✅ 迁移成功 |
| 发顶级评论 | HTTP 201，返回 comment | ✅ depth=0 |
| 发回复（嵌套） | HTTP 201，depth 正确递增 | ✅ depth=1 |
| 超过 5 层嵌套 | HTTP 400 | ✅ 正确拦截 |
| 获取评论列表 | HTTP 200，树形结构 | ✅ 结构正确 |
| 评论点赞 | HTTP 200，toggle 正常 | ✅ 功能正常 |
| 删除自己的评论 | HTTP 200 | ✅ 软删除成功 |
| 帖主删除他人评论 | HTTP 200 | ✅ 权限正确 |
| 非作者非帖主删除 | HTTP 403 | ✅ 权限控制正确 |
| 未登录操作 | HTTP 401 | ✅ 正确拦截 |

---

## 第七步：用户关注系统

### 【本步目标】

- 实现单向关注/取关功能
- 提供关注列表、粉丝列表查询
- 实现关注时间流（仅看关注用户的帖子）
- 用户主页展示关注数/粉丝数/关注状态

### 【技术方案】

#### 新增目录结构

```
src/
├── follows/
│   ├── follows.module.ts
│   ├── follows.service.ts
├── feed/
│   ├── feed.module.ts
│   ├── feed.controller.ts
│   └── feed.service.ts
```

#### 数据库表设计

**follow 表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK | 主键 |
| follower_id | text | NOT NULL, FK → user.id | 关注者 |
| following_id | text | NOT NULL, FK → user.id | 被关注者 |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| UNIQUE(follower_id, following_id) | | 联合唯一 | 防重复关注 |

#### API 设计

| 方法 | 路径 | 鉴权 | 说明 |
|------|------|------|------|
| POST | /api/users/:id/follow | 需登录 | 关注用户 |
| DELETE | /api/users/:id/follow | 需登录 | 取消关注 |
| GET | /api/users/:id/following | 需登录 | 关注列表 |
| GET | /api/users/:id/followers | 需登录 | 粉丝列表 |
| GET | /api/users/:id | 需登录 | 更新：返回关注数/粉丝数/是否已关注 |
| GET | /api/feed/following | 需登录 | 关注时间流 |

### 【需您准备】

- 无新增环境变量

### 【安全验证点】

- ✅ 关注需登录态
- ✅ 禁止自己关注自己
- ✅ 重复关注幂等处理

### 【测试方案与结果】

| 步骤 | 预期 | 结果 |
|------|------|------|
| 编译 | 无错误 | ✅ 编译成功 |
| 数据库迁移 | follow 表创建成功 | ✅ 迁移成功 |
| 关注用户 | HTTP 200，返回 `{ following: true }` | ✅ 关注成功 |
| 取消关注 | HTTP 200，返回 `{ following: false }` | ✅ 取消成功 |
| 关注自己 | HTTP 400，返回错误 | ✅ 正确拦截 |
| 重复关注 | 幂等，返回 `{ following: true }` | ✅ 幂等处理 |
| 关注列表 | HTTP 200，返回用户数组 | ✅ 返回正确 |
| 粉丝列表 | HTTP 200，返回用户数组 | ✅ 返回正确 |
| 用户信息 | HTTP 200，返回 followersCount、followingCount、isFollowing | ✅ 统计正确 |
| 关注时间流 | HTTP 200，仅返回关注用户的帖子 | ✅ 功能正常 |
| 未关注任何人时 | HTTP 200，返回空数组 | ✅ 返回空数组 |

---

## v0.1 技术决策说明

### Redis 缓存层暂缓启用

| 项目 | 说明 |
|------|------|
| 技术组件 | Upstash Redis |
| 设计用途 | 点赞计数缓存、API 限流 |
| 当前状态 | 已声明依赖，暂未启用 |
| 启用时机 | 成长期（DAU > 1万）按需启用 |

**决策理由**：

1. 符合技术方案设计：「成长期按需启用」
2. MVP 聚焦业务验证：避免过早优化
3. 数据库方案可接受：Neon HTTP 驱动适合 Serverless，低流量下性能足够

**当前点赞计数实现**：

- 通过数据库冗余字段 `like_count` 实现
- 点赞时同步更新计数（`+1`/`-1`）
- 联合唯一索引防止重复点赞

**后续优化路径**：

当 DAU 增长需要优化时：
1. 创建 CacheService 抽象层
2. 实现点赞计数 Redis 缓存
3. 添加 API 限流机制
