# 技术框架设计文档

> 本文档记录各步骤的设计方案与决策，采用追加式记录。

---

## 第一步：工程初始化与基础配置

### 【本步目标】
- 交付可运行的 NestJS 工程骨架（含健康检查接口 `GET /health`）
- 一次性声明全部技术栈依赖
- 完成基础配置文件与安全基线

### 【技术方案】

#### 目录结构
```
AI-Coding-Museum/
├── src/
│   ├── main.ts                    # NestJS 入口（端口通过 process.env.PORT 读取，默认 3000）
│   ├── app.module.ts              # 根模块（集成 ConfigModule 全局环境变量管理）
│   └── health/
│       ├── health.controller.ts   # GET /health → { status, timestamp }
│       └── health.module.ts       # 健康检查模块
├── package.json                   # 全量依赖声明
├── tsconfig.json                  # TypeScript 配置（target: ES2022, decorators 支持）
├── tsconfig.build.json            # 构建配置（排除测试文件）
├── nest-cli.json                  # NestJS CLI 配置（编译输出 dist/）
├── .env.example                   # 环境变量模板（仅占位符）
├── .gitignore                     # 排除 .env、*.key、secrets/、dist/
├── SECURITY.md                    # 安全说明（环境变量管理规范）
└── Dockerfile                     # 多阶段构建（Node 22 Alpine）
```

#### 依赖清单
| 类型 | 包名 | 用途 |
|------|------|------|
| dependencies | `@nestjs/core`, `@nestjs/common`, `@nestjs/platform-express` | NestJS 核心（Express 为底层 HTTP 引擎） |
| dependencies | `@nestjs/config` | 环境变量管理 |
| dependencies | `reflect-metadata`, `rxjs` | NestJS 运行时依赖 |
| dependencies | `drizzle-orm` | ORM 核心 |
| dependencies | `better-auth` | 鉴权系统 |
| dependencies | `@neondatabase/serverless` | Neon PostgreSQL 驱动 |
| dependencies | `@upstash/redis` | Upstash Redis 客户端 |
| dependencies | `@aws-sdk/client-s3` | Cloudflare R2 对象存储（S3 兼容） |
| devDependencies | `typescript`, `ts-node`, `tsconfig-paths` | TypeScript 工具链 |
| devDependencies | `@nestjs/cli` | NestJS CLI |
| devDependencies | `@types/node`, `@types/express` | 类型定义 |
| devDependencies | `drizzle-kit` | Schema 迁移工具 |

#### 关键设计决策
1. **Express 作为 NestJS 底层 HTTP 引擎**：NestJS 必须选择 Express 或 Fastify 之一，Express 为默认选项，生态最成熟。业务代码不直接调用 Express API，无需在技术栈选型文档中单独列出。
2. **ConfigModule 全局注入**：`isGlobal: true` 确保所有模块可直接注入 `ConfigService`，统一管理环境变量。
3. **Dockerfile Day 1 就绪**：遵循技术栈方案"容器化隔离"要求，多阶段构建确保生产镜像最小化。

#### 外部服务依赖
本步无（纯骨架验证）

### 【需您准备】
- [x] 变量名：`PORT` | 用途：HTTP 服务端口 | 获取方式：自定义，代码默认值为 3000

### 【安全验证点】
- ✅ 代码中无硬编码密钥（端口通过 `process.env.PORT` 读取）
- ✅ `.gitignore` 已排除 `.env`、`*.key`、`secrets/`、`dist/`
- ✅ `.env.example` 仅含变量名 + 尖括号占位符，无真实值
- ✅ `SECURITY.md` 已提供
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 安装依赖 | `npm install` | 无报错 | ✅ 486 packages 安装成功 |
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `npm run start` | 控制台输出启动信息 | ✅ 正常启动 |
| 健康检查 | `curl http://localhost:3000/health` | HTTP 200, `{ status, timestamp }` | ✅ `{"status":"ok","timestamp":"2026-02-16T10:59:24.851Z"}` |
| Docker 构建 | `docker build -t ai-coding-museum .` | 镜像构建成功 | ✅ 14 步全部完成（Node 22 Alpine 多阶段构建） |
| Docker 运行 | `docker run -p 3000:3000 ai-coding-museum` + `curl /health` | 容器内服务正常响应 | ✅ `{"status":"ok","timestamp":"2026-02-18T12:29:39.366Z"}` |

---

## 第二步：数据库接入与 Drizzle ORM 配置

### 【本步目标】
- 完成 Neon PostgreSQL 数据库连接（通过 Drizzle ORM）
- 建立数据库模块（`DatabaseModule`），全局可注入
- 配置 Drizzle Kit 迁移工具
- 健康检查接口增加数据库连接状态

### 【技术方案】

#### 新增目录结构
```
src/
├── database/
│   ├── database.module.ts         # 全局数据库模块（@Global）
│   ├── database.provider.ts       # Drizzle 实例工厂（neon + drizzle-orm/neon-http）
│   └── schema/
│       └── index.ts               # Schema 统一导出（骨架）
drizzle.config.ts                  # Drizzle Kit 迁移配置（根目录）
```

#### 关键设计决策
1. **Neon HTTP 驱动**：使用 `drizzle-orm/neon-http` + `@neondatabase/serverless` 的 `neon()` 函数，走 HTTP 协议连接 Neon，适合 Serverless 场景（无需维护连接池）。
2. **Provider 注入模式**：通过 `Symbol('DRIZZLE')` 作为注入令牌，业务模块使用 `@Inject(DRIZZLE)` 获取 Drizzle 实例。
3. **全局模块**：`DatabaseModule` 标记 `@Global()`，所有模块无需重复导入即可注入数据库实例。
4. **Schema 骨架**：`schema/index.ts` 导出空对象，后续步骤定义表结构时追加导出。

#### 外部服务依赖
- Neon PostgreSQL（通过 `DATABASE_URL` 环境变量连接）

### 【需您准备】
- [x] 变量名：`DATABASE_URL` | 用途：Neon PostgreSQL 连接串 | 获取方式：Neon 控制台

### 【安全验证点】
- ✅ 数据库连接串仅通过 `process.env.DATABASE_URL` 读取
- ✅ `drizzle.config.ts` 同样通过 `process.env.DATABASE_URL!` 读取
- ✅ `.env.example` 中 `DATABASE_URL=<YOUR_NEON_DATABASE_URL>`（仅占位符）
- ✅ `.env` 包含真实值但被 `.gitignore` 排除
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `node dist/main.js` | 无数据库连接错误 | ✅ 正常启动 |
| 健康检查（含DB） | `curl http://localhost:3000/health` | `{ status, timestamp, database: "connected" }` | ✅ `{"status":"ok","timestamp":"2026-02-18T13:11:32.429Z","database":"connected"}` |

---

## 第三步：用户认证系统（BetterAuth + Drizzle）

### 【本步目标】
- 集成 BetterAuth 认证框架，实现用户注册/登录/会话管理
- 通过 Drizzle ORM 定义认证相关数据库表（user、session、account、verification）
- 提供认证 API 端点（`/api/auth/*`）
- 执行首次数据库迁移（drizzle-kit generate + migrate）

### 【技术方案】

#### 新增目录结构
```
src/
├── auth/
│   ├── auth.module.ts             # 认证模块
│   ├── auth.service.ts            # BetterAuth 实例封装（drizzleAdapter + emailAndPassword）
│   └── auth.controller.ts         # 转发所有 /api/auth/* 请求给 BetterAuth 的 toNodeHandler
├── database/
│   └── schema/
│       └── index.ts               # 新增 4 张 BetterAuth 核心表定义
drizzle/
└── 0000_workable_stone_men.sql    # 首次迁移 SQL（4 表 + 外键）
```

#### 关键设计决策
1. **BetterAuth + Drizzle 适配器**：使用 `drizzleAdapter(db, { provider: 'pg', schema })` 将认证数据存储到 Neon，复用已有的 Drizzle 实例和 Schema 定义。
2. **NestJS 桥接**：通过 `toNodeHandler(auth)` 将 BetterAuth 的 Web 标准请求处理器转为 Node.js Handler，在 NestJS Controller 中使用 `@All()` + `@All('*path')` 捕获所有 `/api/auth/*` 路由。
3. **Schema 定义**：按 BetterAuth 源码中 `getAuthTables()` 的字段定义，在 Drizzle Schema 中手动定义 4 张表，使用 snake_case 数据库列名 + camelCase TypeScript 属性名。
4. **会话管理**：BetterAuth 默认使用 HttpOnly Cookie（`better-auth.session_token`），有效期 7 天，自动续期。

> ⚠️ **Cookie 值格式说明**：
> - `Set-Cookie` 响应头中的值为 `token.HMAC签名`（如 `w4aYWnc1...NJV.5q3qW3A...GUo%3D`），其中 `.` 前是 session token 标识，`.` 后是基于 `AUTH_SECRET` 的 HMAC 签名。
> - JSON 响应体中的 `token` 字段仅包含 `.` 前的 session token 部分，**不含签名**。
> - `get-session` 接口校验时需要完整的 `token.签名` 值（即 `Set-Cookie` 中的原始值），仅传 JSON body 中的 `token` 会因签名缺失导致返回 `null`。
> - 使用 curl 测试时推荐 `-c tmp/cookies.txt`（保存）+ `-b tmp/cookies.txt`（发送）方式，避免手动复制 token 出错。

#### 数据库表结构设计

BetterAuth 要求 4 张核心表，字段定义严格遵循其内部 `getAuthTables()` 规范：

**① user 表 — 用户主表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 用户唯一标识（BetterAuth 自动生成） |
| name | text | NOT NULL | 用户显示名称 |
| email | text | NOT NULL, UNIQUE | 邮箱（登录凭证，全局唯一） |
| email_verified | boolean | NOT NULL, DEFAULT false | 邮箱是否已验证 |
| image | text | 可空 | 用户头像 URL |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

**② session 表 — 会话表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 会话唯一标识 |
| expires_at | timestamp | NOT NULL | 会话过期时间（默认 7 天后） |
| token | text | NOT NULL, UNIQUE | 会话令牌（存入 Cookie 用于身份校验） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |
| ip_address | text | 可空 | 登录时的客户端 IP |
| user_agent | text | 可空 | 登录时的浏览器/客户端标识 |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |

**③ account 表 — 账户表（支持多种登录方式）**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 账户唯一标识 |
| account_id | text | NOT NULL | 提供商侧的账户 ID（邮箱登录时为邮箱） |
| provider_id | text | NOT NULL | 登录提供商标识（如 `credential`、`github`） |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |
| access_token | text | 可空 | OAuth access token（邮箱登录无此字段） |
| refresh_token | text | 可空 | OAuth refresh token |
| id_token | text | 可空 | OAuth id token |
| access_token_expires_at | timestamp | 可空 | access token 过期时间 |
| refresh_token_expires_at | timestamp | 可空 | refresh token 过期时间 |
| scope | text | 可空 | OAuth 授权范围 |
| password | text | 可空 | 邮箱密码登录时的哈希密码（BetterAuth 自动加盐哈希） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：一个 user 可关联多个 account（如同时支持邮箱密码 + GitHub OAuth），通过 `provider_id` 区分。当前仅启用 `emailAndPassword`，预留 OAuth 扩展能力。

**④ verification 表 — 验证表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 验证记录唯一标识 |
| identifier | text | NOT NULL | 验证目标标识（如邮箱地址） |
| value | text | NOT NULL | 验证码/令牌值 |
| expires_at | timestamp | NOT NULL | 验证码过期时间 |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：用于邮箱验证、密码重置等场景的临时令牌存储。当前 MVP 阶段未启用邮箱验证流程，表结构已就绪待后续使用。

**表间关系**：
```
user (1) ←─── (N) session    （一个用户可有多个活跃会话）
user (1) ←─── (N) account    （一个用户可有多种登录方式）
verification                  （独立表，无外键关联）
```

#### 外部服务依赖
- Neon PostgreSQL（已接入）
- BetterAuth 需要 `AUTH_SECRET` 签名密钥

### 【需您准备】
- [x] 变量名：`AUTH_SECRET` | 用途：BetterAuth 签名密钥 | 获取方式：`openssl rand -hex 32` 生成
- [x] 变量名：`BETTER_AUTH_URL` | 用途：应用公开访问地址 | 获取方式：本地开发填 `http://localhost:3000`

### 【安全验证点】
- ✅ `AUTH_SECRET` 仅通过 `process.env.AUTH_SECRET` 读取，未配置时抛出明确错误
- ✅ `.env.example` 新增 `AUTH_SECRET` 和 `BETTER_AUTH_URL` 占位符
- ✅ 密码由 BetterAuth 内部自动加盐哈希，不手写加密逻辑
- ✅ 会话 Cookie 设置 HttpOnly + SameSite=Lax
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 数据库迁移 | `npx drizzle-kit generate` + `npx drizzle-kit migrate` | 迁移执行成功，4 张表已创建 | ✅ 迁移执行成功，user, session, account, verification 表已创建 |
| 用户注册 | `POST /api/auth/sign-up/email` | 返回用户信息 + token | ✅ 返回 `{ token, user: { id, name, email, ... } }` |
| 用户登录 | `POST /api/auth/sign-in/email` | 返回用户信息 + token + Set-Cookie | ✅ 返回用户信息，设置 `better-auth.session_token` Cookie |
| 获取会话 | `GET /api/auth/get-session`（携带 Cookie） | 返回 session + user | ✅ 返回完整会话和用户信息 |
| 健康检查 | `GET /health` | 仍正常返回 | ✅ `{"status":"ok","database":"connected"}` |
