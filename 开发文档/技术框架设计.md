# 技术框架设计文档

> 本文档记录各步骤的设计方案与决策，采用追加式记录。

---

## API 错误响应规范

> 以下规范自第四步起生效，业务接口（`/api/posts`、`/api/users` 等）统一遵循。认证接口（`/api/auth/*`）由 BetterAuth 管理，其 `{ code, message }` 格式与本规范一致，前端可统一解析。

### 【统一错误格式】

所有业务接口的错误响应统一为：

```json
{
  "code": "ERROR_CODE",
  "message": "人类可读的错误描述"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| code | string | 机器可读错误码，大写下划线（如 `UNAUTHORIZED`） |
| message | string | 人类可读描述，供前端展示或日志 |

### 【实现方式】

- 全局 ExceptionFilter：拦截 NestJS 抛出的 `HttpException` 及子类，输出上述格式
- 业务代码通过 `throw new UnauthorizedException('未登录或会话已过期')` 等抛出，由 Filter 转换为 `{ code: "UNAUTHORIZED", message: "..." }`
- HTTP 状态码与 `code` 对应关系见下表

### 【HTTP 状态码与 code 映射】

| HTTP 状态码 | code | 典型场景 |
|------------|------|----------|
| 400 | `BAD_REQUEST` | 参数校验失败、业务规则违反 |
| 401 | `UNAUTHORIZED` | 未登录、会话过期 |
| 403 | `FORBIDDEN` | 无权限访问资源 |
| 404 | `NOT_FOUND` | 资源不存在 |
| 409 | `CONFLICT` | 唯一约束冲突（如重复点赞时的幂等处理） |
| 422 | `UNPROCESSABLE_ENTITY` | 业务逻辑不可执行 |
| 500 | `INTERNAL_SERVER_ERROR` | 未预期服务器错误 |

### 【各接口错误清单】

各业务接口的详细错误码、触发条件在《API接口文档》中按接口补充「失败场景」表格。第四步涉及接口示例：

| 接口 | 失败场景 |
|------|----------|
| POST /api/posts | 401 未登录；400 缺少 content / content 为空 |
| GET /api/posts | 401 未登录 |
| POST /api/posts/:id/like | 401 未登录；404 post 不存在 |
| GET /api/users/me | 401 未登录 |
| GET /api/users/:id | 401 未登录；404 用户不存在 |

---

## 第一步：工程初始化与基础配置

### 【本步目标】
- 交付可运行的 NestJS 工程骨架（含健康检查接口 `GET /health`）
- 一次性声明全部技术栈依赖
- 完成基础配置文件与安全基线

### 【技术方案】

#### 目录结构
```
AI-Coding-Museum/
├── src/
│   ├── main.ts                    # NestJS 入口（端口通过 process.env.PORT 读取，默认 3000）
│   ├── app.module.ts              # 根模块（集成 ConfigModule 全局环境变量管理）
│   └── health/
│       ├── health.controller.ts   # GET /health → { status, timestamp }
│       └── health.module.ts       # 健康检查模块
├── package.json                   # 全量依赖声明
├── tsconfig.json                  # TypeScript 配置（target: ES2022, decorators 支持）
├── tsconfig.build.json            # 构建配置（排除测试文件）
├── nest-cli.json                  # NestJS CLI 配置（编译输出 dist/）
├── .env.example                   # 环境变量模板（仅占位符）
├── .gitignore                     # 排除 .env、*.key、secrets/、dist/
├── SECURITY.md                    # 安全说明（环境变量管理规范）
└── Dockerfile                     # 多阶段构建（Node 22 Alpine）
```

#### 依赖清单
| 类型 | 包名 | 用途 |
|------|------|------|
| dependencies | `@nestjs/core`, `@nestjs/common`, `@nestjs/platform-express` | NestJS 核心（Express 为底层 HTTP 引擎） |
| dependencies | `@nestjs/config` | 环境变量管理 |
| dependencies | `reflect-metadata`, `rxjs` | NestJS 运行时依赖 |
| dependencies | `drizzle-orm` | ORM 核心 |
| dependencies | `better-auth` | 鉴权系统 |
| dependencies | `@neondatabase/serverless` | Neon PostgreSQL 驱动 |
| dependencies | `@upstash/redis` | Upstash Redis 客户端 |
| dependencies | `@aws-sdk/client-s3` | Cloudflare R2 对象存储（S3 兼容） |
| devDependencies | `typescript`, `ts-node`, `tsconfig-paths` | TypeScript 工具链 |
| devDependencies | `@nestjs/cli` | NestJS CLI |
| devDependencies | `@types/node`, `@types/express` | 类型定义 |
| devDependencies | `drizzle-kit` | Schema 迁移工具 |

#### 关键设计决策
1. **Express 作为 NestJS 底层 HTTP 引擎**：NestJS 必须选择 Express 或 Fastify 之一，Express 为默认选项，生态最成熟。业务代码不直接调用 Express API，无需在技术栈选型文档中单独列出。
2. **ConfigModule 全局注入**：`isGlobal: true` 确保所有模块可直接注入 `ConfigService`，统一管理环境变量。
3. **Dockerfile Day 1 就绪**：遵循技术栈方案"容器化隔离"要求，多阶段构建确保生产镜像最小化。

#### 外部服务依赖
本步无（纯骨架验证）

### 【需您准备】
- [x] 变量名：`PORT` | 用途：HTTP 服务端口 | 获取方式：自定义，代码默认值为 3000

### 【安全验证点】
- ✅ 代码中无硬编码密钥（端口通过 `process.env.PORT` 读取）
- ✅ `.gitignore` 已排除 `.env`、`*.key`、`secrets/`、`dist/`
- ✅ `.env.example` 仅含变量名 + 尖括号占位符，无真实值
- ✅ `SECURITY.md` 已提供
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 安装依赖 | `npm install` | 无报错 | ✅ 486 packages 安装成功 |
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `npm run start` | 控制台输出启动信息 | ✅ 正常启动 |
| 健康检查 | `curl http://localhost:3000/health` | HTTP 200；`{ status, timestamp }` | ✅ `{"status":"ok","timestamp":"2026-02-16T10:59:24.851Z"}` |
| Docker 构建 | `docker build -t ai-coding-museum .` | 镜像构建成功 | ✅ 14 步全部完成（Node 22 Alpine 多阶段构建） |
| Docker 运行 | `docker run -p 3000:3000 ai-coding-museum` + `curl /health` | HTTP 200；容器内服务正常响应 | ✅ `{"status":"ok","timestamp":"2026-02-18T12:29:39.366Z"}` |

---

## 第二步：数据库接入与 Drizzle ORM 配置

### 【本步目标】
- 完成 Neon PostgreSQL 数据库连接（通过 Drizzle ORM）
- 建立数据库模块（`DatabaseModule`），全局可注入
- 配置 Drizzle Kit 迁移工具
- 健康检查接口增加数据库连接状态

### 【技术方案】

#### 新增目录结构
```
src/
├── database/
│   ├── database.module.ts         # 全局数据库模块（@Global）
│   ├── database.provider.ts       # Drizzle 实例工厂（neon + drizzle-orm/neon-http）
│   └── schema/
│       └── index.ts               # Schema 统一导出（骨架）
drizzle.config.ts                  # Drizzle Kit 迁移配置（根目录）
```

#### 关键设计决策
1. **Neon HTTP 驱动**：使用 `drizzle-orm/neon-http` + `@neondatabase/serverless` 的 `neon()` 函数，走 HTTP 协议连接 Neon，适合 Serverless 场景（无需维护连接池）。
2. **Provider 注入模式**：通过 `Symbol('DRIZZLE')` 作为注入令牌，业务模块使用 `@Inject(DRIZZLE)` 获取 Drizzle 实例。
3. **全局模块**：`DatabaseModule` 标记 `@Global()`，所有模块无需重复导入即可注入数据库实例。
4. **Schema 骨架**：`schema/index.ts` 导出空对象，后续步骤定义表结构时追加导出。

#### 外部服务依赖
- Neon PostgreSQL（通过 `DATABASE_URL` 环境变量连接）

### 【需您准备】
- [x] 变量名：`DATABASE_URL` | 用途：Neon PostgreSQL 连接串 | 获取方式：Neon 控制台

### 【安全验证点】
- ✅ 数据库连接串仅通过 `process.env.DATABASE_URL` 读取
- ✅ `drizzle.config.ts` 同样通过 `process.env.DATABASE_URL!` 读取
- ✅ `.env.example` 中 `DATABASE_URL=<YOUR_NEON_DATABASE_URL>`（仅占位符）
- ✅ `.env` 包含真实值但被 `.gitignore` 排除
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 启动服务 | `node dist/main.js` | 无数据库连接错误 | ✅ 正常启动 |
| 健康检查（含DB） | `curl http://localhost:3000/health` | HTTP 200；`{ status, timestamp, database: "connected" }` | ✅ `{"status":"ok","timestamp":"2026-02-18T13:11:32.429Z","database":"connected"}` |

---

## 第三步：用户认证系统（BetterAuth + Drizzle）

### 【本步目标】
- 集成 BetterAuth 认证框架，实现用户注册/登录/会话管理
- 通过 Drizzle ORM 定义认证相关数据库表（user、session、account、verification）
- 提供认证 API 端点（`/api/auth/*`）
- 执行首次数据库迁移（drizzle-kit generate + migrate）

### 【技术方案】

#### 新增目录结构
```
src/
├── auth/
│   ├── auth.module.ts             # 认证模块
│   ├── auth.service.ts            # BetterAuth 实例封装（drizzleAdapter + emailAndPassword）
│   └── auth.controller.ts         # 转发所有 /api/auth/* 请求给 BetterAuth 的 toNodeHandler
├── database/
│   └── schema/
│       └── index.ts               # 新增 4 张 BetterAuth 核心表定义
drizzle/
└── 0000_workable_stone_men.sql    # 首次迁移 SQL（4 表 + 外键）
```

#### 关键设计决策
1. **BetterAuth + Drizzle 适配器**：使用 `drizzleAdapter(db, { provider: 'pg', schema })` 将认证数据存储到 Neon，复用已有的 Drizzle 实例和 Schema 定义。
2. **NestJS 桥接**：通过 `toNodeHandler(auth)` 将 BetterAuth 的 Web 标准请求处理器转为 Node.js Handler，在 NestJS Controller 中使用 `@All()` + `@All('*path')` 捕获所有 `/api/auth/*` 路由。
3. **Schema 定义**：按 BetterAuth 源码中 `getAuthTables()` 的字段定义，在 Drizzle Schema 中手动定义 4 张表，使用 snake_case 数据库列名 + camelCase TypeScript 属性名。
4. **会话管理**：BetterAuth 默认使用 HttpOnly Cookie（`better-auth.session_token`），有效期 7 天，自动续期。

> ⚠️ **Cookie 值格式说明**：
> - `Set-Cookie` 响应头中的值为 `token.HMAC签名`（如 `w4aYWnc1...NJV.5q3qW3A...GUo%3D`），其中 `.` 前是 session token 标识，`.` 后是基于 `AUTH_SECRET` 的 HMAC 签名。
> - JSON 响应体中的 `token` 字段仅包含 `.` 前的 session token 部分，**不含签名**。
> - `get-session` 接口校验时需要完整的 `token.签名` 值（即 `Set-Cookie` 中的原始值），仅传 JSON body 中的 `token` 会因签名缺失导致返回 `null`。
> - 使用 curl 测试时推荐 `-c tmp/cookies.txt`（保存）+ `-b tmp/cookies.txt`（发送）方式，避免手动复制 token 出错。

#### 数据库表结构设计

BetterAuth 要求 4 张核心表，字段定义严格遵循其内部 `getAuthTables()` 规范：

**① user 表 — 用户主表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 用户唯一标识（BetterAuth 自动生成） |
| name | text | NOT NULL | 用户显示名称 |
| email | text | NOT NULL, UNIQUE | 邮箱（登录凭证，全局唯一） |
| email_verified | boolean | NOT NULL, DEFAULT false | 邮箱是否已验证 |
| image | text | 可空 | 用户头像 URL |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

**② session 表 — 会话表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 会话唯一标识 |
| expires_at | timestamp | NOT NULL | 会话过期时间（默认 7 天后） |
| token | text | NOT NULL, UNIQUE | 会话令牌（存入 Cookie 用于身份校验） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |
| ip_address | text | 可空 | 登录时的客户端 IP |
| user_agent | text | 可空 | 登录时的浏览器/客户端标识 |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |

**③ account 表 — 账户表（支持多种登录方式）**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 账户唯一标识 |
| account_id | text | NOT NULL | 提供商侧的账户 ID（邮箱登录时为邮箱） |
| provider_id | text | NOT NULL | 登录提供商标识（如 `credential`、`github`） |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 关联用户 |
| access_token | text | 可空 | OAuth access token（邮箱登录无此字段） |
| refresh_token | text | 可空 | OAuth refresh token |
| id_token | text | 可空 | OAuth id token |
| access_token_expires_at | timestamp | 可空 | access token 过期时间 |
| refresh_token_expires_at | timestamp | 可空 | refresh token 过期时间 |
| scope | text | 可空 | OAuth 授权范围 |
| password | text | 可空 | 邮箱密码登录时的哈希密码（BetterAuth 自动加盐哈希） |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：一个 user 可关联多个 account（如同时支持邮箱密码 + GitHub OAuth），通过 `provider_id` 区分。当前仅启用 `emailAndPassword`，预留 OAuth 扩展能力。

**④ verification 表 — 验证表**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | text | PK | 验证记录唯一标识 |
| identifier | text | NOT NULL | 验证目标标识（如邮箱地址） |
| value | text | NOT NULL | 验证码/令牌值 |
| expires_at | timestamp | NOT NULL | 验证码过期时间 |
| created_at | timestamp | NOT NULL, DEFAULT now() | 创建时间 |
| updated_at | timestamp | NOT NULL, DEFAULT now() | 更新时间 |

> **设计说明**：用于邮箱验证、密码重置等场景的临时令牌存储。当前 MVP 阶段未启用邮箱验证流程，表结构已就绪待后续使用。

**表间关系**：
```
user (1) ←─── (N) session    （一个用户可有多个活跃会话）
user (1) ←─── (N) account    （一个用户可有多种登录方式）
verification                  （独立表，无外键关联）
```

#### 外部服务依赖
- Neon PostgreSQL（已接入）
- BetterAuth 需要 `AUTH_SECRET` 签名密钥

### 【需您准备】
- [x] 变量名：`AUTH_SECRET` | 用途：BetterAuth 签名密钥 | 获取方式：`openssl rand -hex 32` 生成
- [x] 变量名：`BETTER_AUTH_URL` | 用途：应用公开访问地址 | 获取方式：本地开发填 `http://localhost:3000`

### 【安全验证点】
- ✅ `AUTH_SECRET` 仅通过 `process.env.AUTH_SECRET` 读取，未配置时抛出明确错误
- ✅ `.env.example` 新增 `AUTH_SECRET` 和 `BETTER_AUTH_URL` 占位符
- ✅ 密码由 BetterAuth 内部自动加盐哈希，不手写加密逻辑
- ✅ 会话 Cookie 设置 HttpOnly + SameSite=Lax
- ✅ 未引用 `demo/` 中的任何代码

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 数据库迁移 | `npx drizzle-kit generate` + `npx drizzle-kit migrate` | 迁移执行成功，4 张表已创建 | ✅ 迁移执行成功，user, session, account, verification 表已创建 |
| 用户注册 | `POST /api/auth/sign-up/email` | HTTP 200；返回用户信息 + token | ✅ 返回 `{ token, user: { id, name, email, ... } }` |
| 用户登录 | `POST /api/auth/sign-in/email` | HTTP 200；返回用户信息 + token + Set-Cookie | ✅ 返回用户信息，设置 `better-auth.session_token` Cookie |
| 获取会话 | `GET /api/auth/get-session`（携带 Cookie） | HTTP 200；返回 session + user | ✅ 返回完整会话和用户信息 |
| 健康检查 | `GET /health` | HTTP 200；仍正常返回 | ✅ `{"status":"ok","database":"connected"}` |

---

## 第四步：核心业务骨架（内容发布 + 点赞 + 用户信息）

### 【本步目标】
- 实现全局 ExceptionFilter，输出统一错误格式（见「API 错误响应规范」）
- 实现内容发布（纯文本）、内容浏览（时间流分页）
- 实现点赞互动（唯一索引防重复）
- 实现用户信息接口（当前用户 / 他人主页）
- 所有业务接口需登录态（BetterAuth Cookie 鉴权）
- **本步不涉及 R2**，media 字段预留为扩展

### 【技术方案】

#### 新增目录结构
```
src/
├── common/
│   └── http-exception.filter.ts   # 全局 ExceptionFilter，统一错误格式
├── auth/
│   └── auth.guard.ts              # 会话鉴权 Guard，供需登录接口复用
├── posts/
│   ├── posts.module.ts
│   ├── posts.controller.ts        # POST/GET /api/posts
│   ├── posts.service.ts
│   └── dto/
├── users/
│   ├── users.module.ts
│   ├── users.controller.ts        # GET /api/users/me, /api/users/:id
│   └── users.service.ts
├── database/
│   └── schema/
│       └── index.ts               # 新增 post、post_like 表
```

#### 数据库表设计

**① post 表 — 内容**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK, DEFAULT gen_random_uuid() | 主键 |
| user_id | text | NOT NULL, FK → user.id (CASCADE) | 作者 |
| content | text | NOT NULL | 正文（纯文本，MVP 无富文本） |
| media_urls | jsonb | 可空 | 预留，格式 `["url1","url2"]`，本步不用 |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| updated_at | timestamp | NOT NULL, DEFAULT now() | |

**② post_like 表 — 点赞**
| 列名 | 类型 | 约束 | 说明 |
|------|------|------|------|
| id | uuid | PK | |
| user_id | text | NOT NULL, FK → user.id | |
| post_id | uuid | NOT NULL, FK → post.id | |
| created_at | timestamp | NOT NULL, DEFAULT now() | |
| UNIQUE(user_id, post_id) | | 联合唯一 | 防重复点赞 |

#### API 设计
| 方法 | 路径 | 鉴权 | 说明 |
|------|------|------|------|
| POST | /api/posts | 需登录 | 发帖（body: `{ content }`） |
| GET | /api/posts | 需登录 | 时间流分页（query: `cursor`, `limit`） |
| POST | /api/posts/:id/like | 需登录 | 点赞/取消点赞（toggle） |
| GET | /api/users/me | 需登录 | 当前用户信息（含 id,name,email,image） |
| GET | /api/users/:id | 需登录 | 他人信息（脱敏：无 email，仅 id,name,image） |

#### 外部服务依赖
- 无新增（仅 Neon + BetterAuth，已接入）

### 【需您准备】
- 无新增环境变量

### 【安全验证点】
- ✅ 所有业务接口需 Cookie 鉴权
- ✅ 发帖/点赞仅限登录用户
- ✅ 他人信息接口不返回 email

### 【测试方案与结果】
| 步骤 | 命令 | 预期 | 结果 |
|------|------|------|------|
| 编译 | `npm run build` | 无编译错误 | ✅ 编译成功 |
| 未登录发帖 | `POST /api/posts` 无 Cookie | HTTP 401；`{ code: "UNAUTHORIZED", message: "..." }` | ✅ `{"code":"UNAUTHORIZED","message":"未登录或会话已过期"}` |
| 发帖 | 登录后 `POST /api/posts` body `{"content":"hello"}` | HTTP 201；返回 post | ✅ 返回 post 对象 |
| 浏览时间流 | `GET /api/posts?limit=10` 带 Cookie | HTTP 200；返回 post 列表 | ✅ 返回数组 |
| 点赞 | `POST /api/posts/:id/like` 带 Cookie | HTTP 200；toggle 成功 | ✅ 返回 `{ liked: true/false }` |
| 当前用户 | `GET /api/users/me` 带 Cookie | HTTP 200；返回 user | ✅ 返回完整 user |
| 他人信息 | `GET /api/users/:id` 带 Cookie | HTTP 200；不包含 email | ✅ 返回脱敏 user |
